/*
 * TLSServer.java
 *
 * Author: Jake Dame
 * Date: 29 Mar 2024
 */

import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.math.BigInteger;
import java.net.ServerSocket;
import java.net.Socket;
import java.security.PrivateKey;
import java.security.cert.Certificate;
import java.util.ArrayList;
import java.util.Arrays;

public class TLSServer
{
    /**
     * The server's record of communication history between itself and the
     * server
     * <p>
     * To simulate the building and tracking of a "communication history"
     * (i.e. any bytes sent / received over-the-wire) during a TLS
     * handshake, any time the .readObject() or writeObject() methods are
     * called, the thing sent / received (or, rather, the byte[] representing
     * it) is manually added to the history_m ArrayList.
     * </p>
     */
    static final ArrayList<byte[]> history_m = new ArrayList<>();

    /**
     * The client's nonce (sometimes called "R" or challenge)
     */
    static final byte[] my_nonce_m = TLSUtil.generate_nonce();

    /**
     * The server's private key (RSA)
     * <p>
     * For this assigment, this key -- which is read from a
     * previously-generated file -- serves a similar purpose to the RSA
     * private exponent "d" of an RSA key pair.
     * </p>
     */
    static PrivateKey RSA_priv_m;

    /**
     * The server's public key (RSA)
     * <p>
     * For this assigment, this key -- which is read from a
     * previously-generated file -- serves a similar purpose to the RSA
     * public exponent "e" of an RSA key pair. It is a Certificate object,
     * because it has been signed by this program's previously-generated
     * certificate authority.
     * </p>
     * <p>
     * A PublicKey object can be generated by calling the .getPublicKey()
     * method on this Certificate object.
     * </p>
     */
    static Certificate RSA_pub_m;

    /**
     * The server's private key (Diffie-Hellman)
     */
    static BigInteger DH_priv_m;

    /**
     * The server's public key (Diffie-Hellman)
     */
    static BigInteger DH_mixture_m;

    static
    {
        try
        {
            RSA_priv_m = TLSUtil.get_RSA_priv( "./Certs_and_Keys/serverPrivateKey.der" );
            RSA_pub_m = TLSUtil.get_RSA_pub( "./Certs_and_Keys/CASignedServerCertificate.pem" );
            DH_priv_m = TLSUtil.generate_DH_priv();
            DH_mixture_m = TLSUtil.generate_DH_pub( DH_priv_m );
        }
        catch ( Exception e )
        {
            e.printStackTrace();
            System.exit( 1 );
        }
    }

    public static void main( String[] args )
    {

        final int PORT_NO = 1025;

        try
        {
            // Construct socket / streams
            final ServerSocket server_socket = new ServerSocket( PORT_NO );
            final Socket client_socket = server_socket.accept();

            final ObjectOutputStream ostream = new ObjectOutputStream( client_socket.getOutputStream() );
            final ObjectInputStream istream = new ObjectInputStream( client_socket.getInputStream() );

            /* -- STEP 1 -- receive ClientHello  */

            // For this assignment, this is just the client's nonce
            final byte[] client_nonce = ( byte[] ) istream.readObject();
            history_m.add( client_nonce );

            /* -- STEP 2 -- send ServerHello */

            ostream.writeObject( RSA_pub_m );
            history_m.add( RSA_pub_m.getEncoded() );

            ostream.writeObject( DH_mixture_m );
            history_m.add( DH_mixture_m.toByteArray() );

            // Sign, encrypt, and send Diffie-Hellman public key
            final byte[] enc_DH_pub = TLSUtil.sign_and_encrypt_DH_public_key( RSA_priv_m, DH_mixture_m );
            ostream.writeObject( enc_DH_pub );
            history_m.add( enc_DH_pub );

            /* -- STEP 3 -- receive pre-master secret message */

            final Certificate client_cert = ( Certificate ) istream.readObject();
            history_m.add( client_cert.getEncoded() );

            final BigInteger client_DH_pub = ( BigInteger ) istream.readObject();
            history_m.add( client_DH_pub.toByteArray() );

            final byte[] client_signed_DH_pub = ( byte[] ) istream.readObject();
            history_m.add( client_signed_DH_pub );

            // Verify client's certificate with certificate authority
            TLSUtil.validate_certificate( client_cert, TLSUtil.get_RSA_pub( "./Certs_and_Keys/CAcertificate.pem" ) );

            // Authenticate server
            TLSUtil.authenticate( client_signed_DH_pub, client_cert, client_DH_pub );

            // Generate shared secret & session keys
            TLSUtil.generate_DH_shared_secret( client_DH_pub, DH_priv_m );
            TLSUtil.HKDF( client_nonce );

            /* -- STEP 4 -- receive client's history */

            // Receive
            final byte[] client_history = ( byte[] ) istream.readObject();

            // Decrypt
            final byte[] dec_client_history = TLSUtil.decrypt( client_history, TLSUtil.client_mac_m, TLSUtil.client_enc_m, TLSUtil.client_iv_m );

            // Compare
            if ( !Arrays.equals( dec_client_history, TLSUtil.compile_history( history_m ) ) )
            {
                throw new RuntimeException( "history mismatch --> server side" );
            }

            history_m.add( client_history );

            /* -- STEP 5 -- send history */

            final byte[] enc_history   = TLSUtil.encrypt( TLSUtil.compile_history( history_m ), TLSUtil.server_mac_m, TLSUtil.server_enc_m, TLSUtil.server_iv_m );

            history_m.add( enc_history );
            ostream.writeObject( enc_history );

            /* -- POST-HANDSHAKE MESSAGING -- */

            /* --- ROUND 1 --- */

            // RECEIVE MESSAGE 1
            final byte[] enc_message_1 = ( byte[] ) istream.readObject();
            final byte[] message_1     = TLSUtil.decrypt( enc_message_1, TLSUtil.client_mac_m, TLSUtil.client_enc_m, TLSUtil.client_iv_m );

            // Test
            final byte[] expect_1 = { 10, 20, 30 };
            if ( !Arrays.equals( message_1, expect_1 ) )
            {
                System.out.println( "First message failed --> server side" );
            }

            // SEND MESSAGE 2
            final byte[] message_2     = { 40, 50, 60 };
            final byte[] enc_message_2 = TLSUtil.encrypt( message_2, TLSUtil.server_mac_m, TLSUtil.server_enc_m, TLSUtil.server_iv_m );

            ostream.writeObject( enc_message_2 );

            /* --- ROUND 2 --- */

            // RECEIVE MESSAGE 3
            final byte[] enc_message_3 = ( byte[] ) istream.readObject();
            final byte[] message_3     = TLSUtil.decrypt( enc_message_3, TLSUtil.client_mac_m, TLSUtil.client_enc_m, TLSUtil.client_iv_m );

            // Test
            byte[] expect_3 = { 70, 80, 90 };
            if ( !Arrays.equals( message_3, expect_3 ) )
            {
                System.out.println( "Second message failed --> server side" );
            }

            // SEND MESSAGE 4
            final byte[] message_4     = { 100, 110, 120 };
            final byte[] enc_message_4 = TLSUtil.encrypt( message_4, TLSUtil.server_mac_m, TLSUtil.server_enc_m, TLSUtil.server_iv_m );

            ostream.writeObject( enc_message_4 );

            /* -- END CONNECTION -- */

            client_socket.close();
            server_socket.close();
        }
        catch ( Exception e )
        {
            e.printStackTrace();
        }

    }

}