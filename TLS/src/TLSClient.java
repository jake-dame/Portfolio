/*
 * TLSClient.java
 *
 * Author: Jake Dame
 * Date: 29 Mar 2024
 */

import java.io.*;
import java.math.BigInteger;
import java.net.Socket;
import java.security.PrivateKey;
import java.security.cert.Certificate;
import java.util.ArrayList;
import java.util.Arrays;

/**
 * Client side of a TCP/TLS connection
 * <p>
 *     This
 * </p>
 * <p>
 *     This implementation implements mutual authentication
 * </p>
 */
public class TLSClient
{
    /**
     * The client's record of communication history between itself and the
     * server
     * <p>
     * To simulate the building and tracking of a "communication history"
     * (i.e. any bytes sent / received over-the-wire) during a TLS
     * handshake, any time the .readObject() or writeObject() methods are
     * called, the thing sent / received (or, rather, the byte[] representing
     * it) is manually added to the history_m ArrayList.
     * </p>
     */
    static final ArrayList<byte[]> history_m = new ArrayList<>();

    /**
     * The client's nonce (sometimes called "R" or challenge)
     */
    static final byte[] nonce_m = TLSUtil.generate_nonce();

    /**
     * The client's private key (RSA)
     * <p>
     * For this assigment, this key -- which is read from a
     * previously-generated file -- serves a similar purpose to the RSA
     * private exponent "d" of an RSA key pair.
     * </p>
     */
    static PrivateKey RSA_priv_m;

    /**
     * The client's public key (RSA)
     * <p>
     * For this assigment, this key -- which is read from a
     * previously-generated file -- serves a similar purpose to the RSA
     * public exponent "e" of an RSA key pair. It is a Certificate object,
     * because it has been signed by this program's previously-generated
     * certificate authority.
     * </p>
     * <p>
     * A PublicKey object can be generated by calling the .getPublicKey()
     * method on this Certificate object.
     * </p>
     */
    static Certificate RSA_pub_m;

    /**
     * The client's private key (Diffie-Hellman)
     */
    static BigInteger DH_priv_m;

    /**
     * The client's public key (Diffie-Hellman)
     */
    static BigInteger DH_mixture_m;

    static
    {
        try
        {
            RSA_priv_m = TLSUtil.get_RSA_priv( "./Certs_and_Keys/clientPrivateKey.der" );
            RSA_pub_m = TLSUtil.get_RSA_pub( "./Certs_and_Keys/CASignedClientCertificate.pem" );
            DH_priv_m = TLSUtil.generate_DH_priv();
            DH_mixture_m = TLSUtil.generate_DH_pub( DH_priv_m );
        }
        catch ( Exception e )
        {
            e.printStackTrace();
        }
    }

    public static void main( String[] args )
    {

        final int SERVER_PORT_NO = 1025;

        try
        {
            // Construct socket / streams
            final Socket socket = new Socket( "localhost", SERVER_PORT_NO );

            final ObjectInputStream  istream = new ObjectInputStream( socket.getInputStream() );
            final ObjectOutputStream ostream = new ObjectOutputStream( socket.getOutputStream() );

            /* -- STEP 1 -- send ClientHello  */

            // For this assignment, this is just the client's nonce
            ostream.writeObject( nonce_m );
            history_m.add( nonce_m );
            System.out.println( Arrays.toString( nonce_m ) );
            for( byte b : nonce_m )
            {
                System.out.println( Integer.toHexString( b ) );
            }


            /* -- STEP 2 -- receive ServerHello */

            final Certificate server_cert = ( Certificate ) istream.readObject();
            history_m.add( server_cert.getEncoded() );

            final BigInteger server_DH_pub = ( BigInteger ) istream.readObject();
            history_m.add( server_DH_pub.toByteArray() );

            final byte[] server_signed_DH_pub = ( byte[] ) istream.readObject();
            history_m.add( server_signed_DH_pub );

            // Verify server's certificate with certificate authority
            TLSUtil.validate_certificate( server_cert, TLSUtil.get_RSA_pub( "./Certs_and_Keys/CAcertificate.pem" ) );

            // Authenticate server
            TLSUtil.authenticate( server_signed_DH_pub, server_cert, server_DH_pub );

            // Generate shared secret & session keys
            TLSUtil.generate_DH_shared_secret( server_DH_pub, DH_priv_m );
            TLSUtil.HKDF( nonce_m );

            /* -- STEP 3 -- send pre-master secret message */

            ostream.writeObject( RSA_pub_m );
            history_m.add( RSA_pub_m.getEncoded() );

            ostream.writeObject( DH_mixture_m );
            history_m.add( DH_mixture_m.toByteArray() );

            // Sign, encrypt, and send Diffie-Hellman public key
            final byte[] enc_DH_pub = TLSUtil.sign_and_encrypt_DH_public_key( RSA_priv_m, DH_mixture_m );
            ostream.writeObject( enc_DH_pub );
            history_m.add( enc_DH_pub );

            /* -- STEP 4 -- send history */

            final byte[] enc_history = TLSUtil.encrypt( TLSUtil.compile_history( history_m ), TLSUtil.client_mac_m, TLSUtil.client_enc_m, TLSUtil.client_iv_m );

            ostream.writeObject( enc_history );
            history_m.add( enc_history );

            /* -- STEP 5 -- receive server's history */

            // Receive
            final byte[] server_history = ( byte[] ) istream.readObject();

            // Decrypt
            final byte[] dec_server_history = TLSUtil.decrypt( server_history, TLSUtil.server_mac_m, TLSUtil.server_enc_m, TLSUtil.server_iv_m );

            // Compare
            if ( !Arrays.equals( dec_server_history, TLSUtil.compile_history( history_m ) ) )
            {
                throw new RuntimeException( "history mismatch --> client side" );
            }

            /* -- POST-HANDSHAKE MESSAGING -- */

            /* --- ROUND 1 --- */

            // SEND MESSAGE 1
            final byte[] message_1     = { 10, 20, 30 };
            final byte[] enc_message_1 = TLSUtil.encrypt( message_1, TLSUtil.client_mac_m, TLSUtil.client_enc_m, TLSUtil.client_iv_m );

            ostream.writeObject( enc_message_1 );

            // RECEIVE MESSAGE 2
            final byte[] enc_message_2 = ( byte[] ) istream.readObject();
            final byte[] message_2     = TLSUtil.decrypt( enc_message_2, TLSUtil.server_mac_m, TLSUtil.server_enc_m, TLSUtil.server_iv_m );

            // Test
            final byte[] expect_2 = { 40, 50, 60 };
            if ( !Arrays.equals( message_2, expect_2 ) )
            {
                System.out.println( "First message failed --> client side" );
            }

            /* --- ROUND 2 --- */

            // SEND MESSAGE 3
            final byte[] message_3     = { 70, 80, 90 };
            final byte[] enc_message_3 = TLSUtil.encrypt( message_3, TLSUtil.client_mac_m, TLSUtil.client_enc_m, TLSUtil.client_iv_m );

            ostream.writeObject( enc_message_3 );

            // RECEIVE MESSAGE 4
            final byte[] enc_message_4 = ( byte[] ) istream.readObject();
            final byte[] message_4     = TLSUtil.decrypt( enc_message_4, TLSUtil.server_mac_m, TLSUtil.server_enc_m, TLSUtil.server_iv_m );

            // Test
            final byte[] expect_4 = { 100, 110, 120 };
            if ( !Arrays.equals( message_4, expect_4 ) )
            {
                System.out.println( "Second message failed --> client side" );
            }

            /* -- END CONNECTION -- */

            socket.close();
        }
        catch ( Exception e )
        {
            e.printStackTrace();
        }

    }

}